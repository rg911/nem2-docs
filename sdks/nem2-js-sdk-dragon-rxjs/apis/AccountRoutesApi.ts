// tslint:disable
/*
 * Copyright 2019 NEM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Catapult REST API Reference
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.7.15
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Observable } from 'rxjs';
import { BaseAPI, RequiredError, HttpHeaders, HttpQuery, COLLECTION_FORMATS } from '../runtime';
import {
    AccountIds,
    AccountInfoDTO,
    AccountNamesDTO,
    AccountPropertiesInfoDTO,
    MultisigAccountGraphInfoDTO,
    MultisigAccountInfoDTO,
    TransactionInfoDTO,
} from '../models';

export interface GetAccountInfoRequest {
    accountId: string;
}

export interface GetAccountMultisigRequest {
    accountId: string;
}

export interface GetAccountMultisigGraphRequest {
    accountId: string;
}

export interface GetAccountPropertiesRequest {
    accountId: string;
}

export interface GetAccountPropertiesFromAccountsRequest {
    accountIds: AccountIds;
}

export interface GetAccountsInfoRequest {
    accountIds: AccountIds;
}

export interface GetAccountsNamesRequest {
    accountIds: AccountIds;
}

export interface IncomingTransactionsRequest {
    publicKey: string;
    pageSize?: number;
    id?: string;
    ordering?: string;
}

export interface OutgoingTransactionsRequest {
    publicKey: string;
    pageSize?: number;
    id?: string;
    ordering?: string;
}

export interface PartialTransactionsRequest {
    publicKey: string;
    pageSize?: number;
    id?: string;
    ordering?: string;
}

export interface TransactionsRequest {
    publicKey: string;
    pageSize?: number;
    id?: string;
    ordering?: string;
}

export interface UnconfirmedTransactionsRequest {
    publicKey: string;
    pageSize?: number;
    id?: string;
    ordering?: string;
}

/**
 * no description
 */
export class AccountRoutesApi extends BaseAPI {

    /**
     * Returns the account information.
     * Get account information
     */
    getAccountInfo(requestParameters: GetAccountInfoRequest): Observable<AccountInfoDTO> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccountInfo.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        return this.request<AccountInfoDTO>({
            path: `/account/{accountId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Returns the multisig account information.
     * Get multisig account information
     */
    getAccountMultisig(requestParameters: GetAccountMultisigRequest): Observable<MultisigAccountInfoDTO> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccountMultisig.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        return this.request<MultisigAccountInfoDTO>({
            path: `/account/{accountId}/multisig`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Returns the multisig account graph.
     * Get multisig account graph information
     */
    getAccountMultisigGraph(requestParameters: GetAccountMultisigGraphRequest): Observable<Array<MultisigAccountGraphInfoDTO>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccountMultisigGraph.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        return this.request<Array<MultisigAccountGraphInfoDTO>>({
            path: `/account/{accountId}/multisig/graph`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Returns the configurable properties for a given account.
     * Get account configurable properties information
     */
    getAccountProperties(requestParameters: GetAccountPropertiesRequest): Observable<AccountPropertiesInfoDTO> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getAccountProperties.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        return this.request<AccountPropertiesInfoDTO>({
            path: `/account/{accountId}/properties/`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Returns the configurable properties for a given array of addresses.
     * Get account properties for given array of addresses
     */
    getAccountPropertiesFromAccounts(requestParameters: GetAccountPropertiesFromAccountsRequest): Observable<Array<AccountPropertiesInfoDTO>> {
        if (requestParameters.accountIds === null || requestParameters.accountIds === undefined) {
            throw new RequiredError('accountIds','Required parameter requestParameters.accountIds was null or undefined when calling getAccountPropertiesFromAccounts.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Array<AccountPropertiesInfoDTO>>({
            path: `/account/properties`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.accountIds,
        });
    }

    /**
     * Returns the account information for an array of accounts.
     * Get accounts information
     */
    getAccountsInfo(requestParameters: GetAccountsInfoRequest): Observable<Array<AccountInfoDTO>> {
        if (requestParameters.accountIds === null || requestParameters.accountIds === undefined) {
            throw new RequiredError('accountIds','Required parameter requestParameters.accountIds was null or undefined when calling getAccountsInfo.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Array<AccountInfoDTO>>({
            path: `/account`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.accountIds,
        });
    }

    /**
     * Returns friendly names for accounts.
     * Get readable names for a set of accountIds.
     */
    getAccountsNames(requestParameters: GetAccountsNamesRequest): Observable<Array<AccountNamesDTO>> {
        if (requestParameters.accountIds === null || requestParameters.accountIds === undefined) {
            throw new RequiredError('accountIds','Required parameter requestParameters.accountIds was null or undefined when calling getAccountsNames.');
        }

        const queryParameters: HttpQuery = {};

        const headerParameters: HttpHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        return this.request<Array<AccountNamesDTO>>({
            path: `/account/names`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.accountIds,
        });
    }

    /**
     * Gets an array of incoming transactions. A transaction is said to be incoming with respect to an account if the account is the recipient of the transaction. 
     * Get incoming transactions
     */
    incomingTransactions(requestParameters: IncomingTransactionsRequest): Observable<Array<TransactionInfoDTO>> {
        if (requestParameters.publicKey === null || requestParameters.publicKey === undefined) {
            throw new RequiredError('publicKey','Required parameter requestParameters.publicKey was null or undefined when calling incomingTransactions.');
        }

        const queryParameters: HttpQuery = {};

        if (requestParameters.pageSize !== undefined && requestParameters.pageSize !== null) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.ordering !== undefined && requestParameters.ordering !== null) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        const headerParameters: HttpHeaders = {};

        return this.request<Array<TransactionInfoDTO>>({
            path: `/account/{publicKey}/transactions/incoming`.replace(`{${"publicKey"}}`, encodeURIComponent(String(requestParameters.publicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Gets an array of outgoing transactions. A transaction is said to be outgoing with respect to an account if the account is the sender of the transaction.
     * Get outgoing transactions
     */
    outgoingTransactions(requestParameters: OutgoingTransactionsRequest): Observable<Array<TransactionInfoDTO>> {
        if (requestParameters.publicKey === null || requestParameters.publicKey === undefined) {
            throw new RequiredError('publicKey','Required parameter requestParameters.publicKey was null or undefined when calling outgoingTransactions.');
        }

        const queryParameters: HttpQuery = {};

        if (requestParameters.pageSize !== undefined && requestParameters.pageSize !== null) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.ordering !== undefined && requestParameters.ordering !== null) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        const headerParameters: HttpHeaders = {};

        return this.request<Array<TransactionInfoDTO>>({
            path: `/account/{publicKey}/transactions/outgoing`.replace(`{${"publicKey"}}`, encodeURIComponent(String(requestParameters.publicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Gets an array of aggregate bonded transactions where the account is the sender or requires to cosign the transaction. 
     * Get aggregate bonded transactions information
     */
    partialTransactions(requestParameters: PartialTransactionsRequest): Observable<Array<TransactionInfoDTO>> {
        if (requestParameters.publicKey === null || requestParameters.publicKey === undefined) {
            throw new RequiredError('publicKey','Required parameter requestParameters.publicKey was null or undefined when calling partialTransactions.');
        }

        const queryParameters: HttpQuery = {};

        if (requestParameters.pageSize !== undefined && requestParameters.pageSize !== null) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.ordering !== undefined && requestParameters.ordering !== null) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        const headerParameters: HttpHeaders = {};

        return this.request<Array<TransactionInfoDTO>>({
            path: `/account/{publicKey}/transactions/partial`.replace(`{${"publicKey"}}`, encodeURIComponent(String(requestParameters.publicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Gets an array of transactions for which an account is the sender or receiver.
     * Get confirmed transactions
     */
    transactions(requestParameters: TransactionsRequest): Observable<Array<TransactionInfoDTO>> {
        if (requestParameters.publicKey === null || requestParameters.publicKey === undefined) {
            throw new RequiredError('publicKey','Required parameter requestParameters.publicKey was null or undefined when calling transactions.');
        }

        const queryParameters: HttpQuery = {};

        if (requestParameters.pageSize !== undefined && requestParameters.pageSize !== null) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.ordering !== undefined && requestParameters.ordering !== null) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        const headerParameters: HttpHeaders = {};

        return this.request<Array<TransactionInfoDTO>>({
            path: `/account/{publicKey}/transactions`.replace(`{${"publicKey"}}`, encodeURIComponent(String(requestParameters.publicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

    /**
     * Gets the array of transactions not included in a block where an account is the sender or receiver. 
     * Get unconfirmed transactions
     */
    unconfirmedTransactions(requestParameters: UnconfirmedTransactionsRequest): Observable<Array<TransactionInfoDTO>> {
        if (requestParameters.publicKey === null || requestParameters.publicKey === undefined) {
            throw new RequiredError('publicKey','Required parameter requestParameters.publicKey was null or undefined when calling unconfirmedTransactions.');
        }

        const queryParameters: HttpQuery = {};

        if (requestParameters.pageSize !== undefined && requestParameters.pageSize !== null) {
            queryParameters['pageSize'] = requestParameters.pageSize;
        }

        if (requestParameters.id !== undefined && requestParameters.id !== null) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.ordering !== undefined && requestParameters.ordering !== null) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        const headerParameters: HttpHeaders = {};

        return this.request<Array<TransactionInfoDTO>>({
            path: `/account/{publicKey}/transactions/unconfirmed`.replace(`{${"publicKey"}}`, encodeURIComponent(String(requestParameters.publicKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });
    }

}
